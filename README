# EZmath - Mathematics Library for EZ Language

A comprehensive mathematics library for the EZ programming language, providing trigonometric functions, vector operations, statistics, and moreâ€”all implemented from scratch using mathematical algorithms.



## Features

ðŸ“ **Trigonometric Functions**
- Sine, Cosine, Tangent (radians & degrees)
- Taylor series implementation for high accuracy
- Angle normalization and conversion

ðŸ”¢ **Mathematical Utilities**
- Power, Square Root, Absolute Value
- Exponential and Natural Logarithm
- Factorial calculation
- Rounding (floor, ceil, round)

ðŸ“Š **Vector Operations**
- 2D and 3D vector support
- Length, normalization, dot product
- 2D rotation and transformations
- Angle calculations

ðŸ“ˆ **Statistics**
- Mean, Variance, Standard Deviation
- Array-based calculations

ðŸŽ¯ **Utility Functions**
- Linear interpolation (lerp)
- Clamping values
- Angle conversions (degrees â†” radians)

---

## Installation

```bash
# Install from GitHub
ez install math

# Or install from local directory
cd Zmath
ez install .
```

---

## Quick Start

```ez
use "math"

// Basic trigonometry
angle = 45
out "cos(45Â°) =", cosd(angle)
out "sin(45Â°) =", sind(angle)

// Vector operations
v1 = vec2(3, 4)
out "Vector length:", vec_length(v1)

// Statistics
data = [1, 2, 3, 4, 5]
out "Mean:", mean(data)
out "Standard deviation:", stddev(data)
```

---

## API Reference

### Constants

#### `pi()`
Returns the value of Ï€ (pi).

```ez
circle_circumference = 2 * pi() * radius
```

---

### Angle Conversion

#### `deg_to_rad(degrees)`
Convert degrees to radians.

**Parameters:**
- `degrees` - Angle in degrees

**Returns:** Angle in radians

```ez
radians = deg_to_rad(180)  // Ï€ radians
```

#### `rad_to_deg(radians)`
Convert radians to degrees.

**Parameters:**
- `radians` - Angle in radians

**Returns:** Angle in degrees

```ez
degrees = rad_to_deg(pi())  // 180 degrees
```

---

### Trigonometric Functions

All trigonometric functions use **Taylor series approximation** for accurate calculations without external dependencies.

#### `cos(angle)`
Calculate cosine (radians).

**Parameters:**
- `angle` - Angle in radians

**Returns:** Cosine value [-1, 1]

```ez
result = cos(pi() / 3)  // cos(60Â°) = 0.5
```

#### `cosd(degrees)`
Calculate cosine (degrees).

```ez
result = cosd(60)  // 0.5
```

#### `sin(angle)`
Calculate sine (radians).

**Implementation:** Uses the identity sin(x) = cos(Ï€/2 - x)

```ez
result = sin(pi() / 2)  // 1.0
```

#### `sind(degrees)`
Calculate sine (degrees).

```ez
result = sind(90)  // 1.0
```

#### `tan(angle)`
Calculate tangent (radians).

```ez
result = tan(pi() / 4)  // 1.0
```

#### `tand(degrees)`
Calculate tangent (degrees).

```ez
result = tand(45)  // 1.0
```

**Example - Trigonometry:**
```ez
use "math"

// Calculate all trig functions for 30Â°
angle = 30

out "For angle", angle, "degrees:"
out "  sin =", sind(angle)
out "  cos =", cosd(angle)
out "  tan =", tand(angle)

// Output:
// For angle 30 degrees:
//   sin = 0.5
//   cos = 0.866025
//   tan = 0.57735
```

---

### Basic Math Functions

#### `abs(x)`
Absolute value.

```ez
abs(-5)    // 5
abs(3.14)  // 3.14
```

#### `pow(base, exponent)`
Power function (integer exponents only).

```ez
pow(2, 8)   // 256
pow(10, 3)  // 1000
```

#### `sqrt(x)`
Square root using Babylonian method.

**Parameters:**
- `x` - Non-negative number

**Returns:** Square root of x

```ez
sqrt(16)   // 4
sqrt(2)    // 1.41421
```

âš ï¸ **Note:** Negative inputs will cause an error.

#### `exp(x)`
Exponential function e^x.

**Implementation:** Taylor series approximation

```ez
exp(1)   // e â‰ˆ 2.71828
exp(0)   // 1
exp(2)   // eÂ² â‰ˆ 7.389
```

#### `ln(x)`
Natural logarithm.

**Parameters:**
- `x` - Positive number

**Returns:** ln(x)

```ez
ln(2.71828)  // â‰ˆ 1 (ln(e))
ln(10)       // â‰ˆ 2.302585
```

âš ï¸ **Note:** Only positive inputs are valid.

#### `factorial(n)`
Calculate factorial n!

```ez
factorial(5)  // 120
factorial(0)  // 1
factorial(3)  // 6
```

---

### Rounding Functions

#### `round(x)`
Round to nearest integer.

```ez
round(3.7)   // 4
round(3.2)   // 3
round(-2.5)  // -3
```

#### `floor(x)`
Round down to integer.

```ez
floor(3.9)   // 3
floor(-2.1)  // -3
```

#### `ceil(x)`
Round up to integer.

```ez
ceil(3.1)   // 4
ceil(-2.9)  // -2
```

---

### Vector Operations

#### `vec2(x, y)`
Create 2D vector.

**Returns:** Struct with `x` and `y` fields

```ez
position = vec2(10, 20)
out position.x, position.y
```

#### `vec3(x, y, z)`
Create 3D vector.

**Returns:** Struct with `x`, `y`, and `z` fields

```ez
point = vec3(1, 2, 3)
```

#### `vec_length(vec)`
Calculate vector magnitude/length.

**Supports:** 2D and 3D vectors

```ez
v = vec2(3, 4)
length = vec_length(v)  // 5
```

#### `vec_normalize(vec)`
Normalize vector to unit length.

**Returns:** Normalized vector (length = 1)

```ez
v = vec2(3, 4)
unit_v = vec_normalize(v)
// unit_v = {x: 0.6, y: 0.8}
```

#### `vec_dot(v1, v2)`
Calculate dot product.

**Supports:** 2D and 3D vectors

```ez
v1 = vec2(1, 2)
v2 = vec2(3, 4)
dot = vec_dot(v1, v2)  // 11
```

**Example - Vector Math:**
```ez
use "math"

// Create vectors
a = vec3(1, 0, 0)
b = vec3(0, 1, 0)

// Calculate properties
dot_product = vec_dot(a, b)  // 0 (perpendicular)
length_a = vec_length(a)     // 1

out "Dot product:", dot_product
out "Length of a:", length_a
```

---

### 2D Transformations

#### `rotate_point(point, angle_degrees)`
Rotate a 2D point around origin.

**Parameters:**
- `point` - 2D vector {x, y}
- `angle_degrees` - Rotation angle in degrees (counter-clockwise)

**Returns:** Rotated point

```ez
point = vec2(1, 0)
rotated = rotate_point(point, 90)
// rotated â‰ˆ {x: 0, y: 1}
```

**Example - Rotation:**
```ez
use "EZmath"

// Create a point at (10, 0)
point = vec2(10, 0)

// Rotate by 45 degrees
rotated = rotate_point(point, 45)

out "Original:", point.x, point.y
out "Rotated:", rotated.x, rotated.y
// Rotated: 7.07, 7.07
```

---

### Statistics

#### `mean(arr)`
Calculate arithmetic mean (average).

**Parameters:**
- `arr` - Array of numbers

```ez
data = [1, 2, 3, 4, 5]
avg = mean(data)  // 3
```

#### `variance(arr)`
Calculate variance.

```ez
data = [1, 2, 3, 4, 5]
var = variance(data)  // 2
```

#### `stddev(arr)`
Calculate standard deviation.

```ez
data = [1, 2, 3, 4, 5]
sd = stddev(data)  // 1.414
```

**Example - Statistics:**
```ez
use "math"

test_scores = [85, 90, 78, 92, 88, 95]

average = mean(test_scores)
std_dev = stddev(test_scores)

out "Average score:", average
out "Standard deviation:", std_dev
out "Variance:", variance(test_scores)

// Output:
// Average score: 88
// Standard deviation: 5.85
// Variance: 34.22
```

---

### Utility Functions

#### `clamp(value, min_val, max_val)`
Constrain value to range.

```ez
clamp(150, 0, 100)  // 100
clamp(-10, 0, 100)  // 0
clamp(50, 0, 100)   // 50
```

#### `lerp(a, b, t)`
Linear interpolation between a and b.

**Parameters:**
- `a` - Start value
- `b` - End value
- `t` - Interpolation factor [0, 1]

```ez
lerp(0, 100, 0.5)   // 50
lerp(10, 20, 0.25)  // 12.5
```

**Example - Animation:**
```ez
use "math"

start_pos = 0
end_pos = 100

// Animate from start to end
repeat frame = 0 to 10 {
    t = frame / 10.0
    current_pos = lerp(start_pos, end_pos, t)
    out "Frame", frame, "Position:", current_pos
}
```

#### `angle_between(v1, v2)`
Calculate angle between two vectors.

**Returns:** Angle in degrees

```ez
v1 = vec2(1, 0)
v2 = vec2(0, 1)
angle = angle_between(v1, v2)  // 90 degrees
```

---

## Complete Examples

### Example 1: Circle Calculator

```ez
use "math"

task calculate_circle(radius) {
    area = pi() * radius * radius
    circumference = 2 * pi() * radius
    
    out "Circle with radius", radius
    out "  Area:", area
    out "  Circumference:", circumference
}

calculate_circle(5)
// Output:
// Circle with radius 5
//   Area: 78.53975
//   Circumference: 31.4159
```

### Example 2: Projectile Motion

```ez
use "math"

task projectile(velocity, angle_degrees, time) {
    angle_rad = deg_to_rad(angle_degrees)
    g = 9.81  // gravity
    
    vx = velocity * cos(angle_rad)
    vy = velocity * sin(angle_rad)
    
    x = vx * time
    y = vy * time - 0.5 * g * time * time
    
    out "Time:", time, "s"
    out "  Position: (", x, ",", y, ")"
}

// Launch at 45Â° with 20 m/s
repeat t = 0 to 5 {
    projectile(20, 45, t)
}
```

### Example 3: Vector Field

```ez
use "math"

task vector_field(x, y) {
    // Create a circular vector field
    angle = rad_to_deg(angle_between(vec2(x, y), vec2(1, 0)))
    
    // Rotate 90 degrees for circular flow
    rotated = rotate_point(vec2(x, y), 90)
    
    normalized = vec_normalize(rotated)
    
    out "At (", x, ",", y, ") â†’ (", normalized.x, ",", normalized.y, ")"
}

// Sample points
repeat x = -2 to 2 {
    repeat y = -2 to 2 {
        when x notequal 0 or y notequal 0 {
            vector_field(x, y)
        }
    }
}
```

### Example 4: Statistics Dashboard

```ez
use "math"

task analyze_data(dataset) {
    out "Dataset Analysis"
    out "================="
    out "Data:", dataset
    out ""
    
    avg = mean(dataset)
    sd = stddev(dataset)
    var = variance(dataset)
    
    out "Mean:", avg
    out "Standard Deviation:", sd
    out "Variance:", var
    out ""
    
    // Find values within 1 standard deviation
    lower = avg - sd
    upper = avg + sd
    
    count = 0
    get val in dataset {
        when val >= lower and val <= upper {
            count = count + 1
        }
    }
    
    percentage = (count / len(dataset)) * 100
    out count, "values (", percentage, "%) within 1Ïƒ"
}

sales_data = [120, 135, 118, 142, 128, 131, 125, 139, 122, 136]
analyze_data(sales_data)
```

### Example 5: Game Physics Helper

```ez
use "math"

// Player position and velocity
player_pos = vec2(0, 0)
player_vel = vec2(5, 3)

task update_player(dt) {
    // Update position
    player_pos.x = player_pos.x + player_vel.x * dt
    player_pos.y = player_pos.y + player_vel.y * dt
    
    // Calculate speed
    speed = vec_length(player_vel)
    
    // Rotate velocity (simulate turning)
    player_vel = rotate_point(player_vel, 2)  // 2Â° per frame
    
    out "Position:", player_pos.x, player_pos.y
    out "Speed:", speed
}

// Simulate 10 frames
repeat frame = 1 to 10 {
    update_player(0.016)  // ~60 FPS
}
```

---

## Mathematical Implementation Details

### Trigonometric Functions

EZmath implements trigonometry using **Taylor series expansion**:

**Cosine:**
```
cos(x) = 1 - xÂ²/2! + xâ´/4! - xâ¶/6! + xâ¸/8! - ...
```

The implementation uses 6 terms for accuracy within 0.0001 for most angles.

**Features:**
- Automatic angle normalization to [-Ï€, Ï€]
- Optimized term calculation
- No external dependencies

### Square Root

Uses the **Babylonian method** (Newton's method):
```
x_{n+1} = (x_n + S/x_n) / 2
```

Converges in ~10 iterations for most inputs.

### Exponential and Logarithm

**e^x Taylor series:**
```
e^x = 1 + x + xÂ²/2! + xÂ³/3! + ...
```

**ln(x) using transformation:**
```
ln(x) = 2 * Î£[(x-1)/(x+1)]^(2k+1) / (2k+1)
```

---

## Accuracy and Limitations

### Accuracy
- **Trigonometric functions:** Â±0.0001 for angles in [-2Ï€, 2Ï€]
- **sqrt():** ~6 decimal places
- **exp() & ln():** ~5 decimal places

### Limitations
- `pow()` only supports integer exponents
- Large factorial values may overflow
- Trigonometric functions less accurate for very large angles
- No complex number support

### Recommendations
For production applications requiring higher precision:
- Use hardware math functions when available
- Increase Taylor series terms for better accuracy
- Add overflow checking for large values

---

## Performance Tips

1. **Cache repeated calculations:**
   ```ez
   pi_val = pi()  // Store instead of calling repeatedly
   ```

2. **Prefer radians internally:**
   ```ez
   // Convert once, use everywhere
   angle_rad = deg_to_rad(angle_deg)
   ```

3. **Normalize vectors once:**
   ```ez
   direction = vec_normalize(velocity)
   ```

4. **Use integer operations when possible:**
   ```ez
   // Faster than pow(2, 8)
   result = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2
   ```

---

## Testing

Run the built-in test suite:

```ez
use "EZmath"

test()
```

This will output verification of:
- Trigonometric functions
- Angle conversions
- Common mathematical identities

---

## Contributing

Contributions are welcome! Areas for improvement:

- [ ] Add inverse trigonometric functions (asin, acos, atan)
- [ ] Implement hyperbolic functions (sinh, cosh, tanh)
- [ ] Add matrix operations
- [ ] Complex number support
- [ ] More statistical functions (median, mode, percentile)
- [ ] Optimization for large datasets
- [ ] Unit tests for all functions

---

## Roadmap

**Version 1.1:**
- Inverse trig functions
- Matrix 2x2 and 3x3 operations
- Quaternion support

**Version 1.2:**
- Random number generators (various distributions)
- Polynomial operations
- Integration/differentiation approximations

**Version 2.0:**
- Complex numbers
- FFT (Fast Fourier Transform)
- Optimization algorithms

---

## License

MIT License - see LICENSE file for details.

## Support

- Documentation: [GitHub Wiki](https://github.com/imabd645/EZmath/wiki)
- Issues: [GitHub Issues](https://github.com/imabd645/EZmath/issues)
- Examples: [examples/](examples/)

---

## Acknowledgments

Mathematical algorithms based on:
- Taylor Series Approximations
- Babylonian Method (Square Roots)
- Newton's Method
- Classical numerical analysis techniques

---

**Made by Abdullah Masood**

*Pure EZ implementation - no external dependencies required!*
